
Можно ли вычислять биткоины быстрее, проще или легче?

Все началось с того, что я решил поближе познакомиться с биткоинами. Хотелось понять, как их добывают. Статьи про биткоины и блокчейны последнее время встречаются часто, но таких, чтобы со всеми техническими подробностями, таких не очень много.

Самый простой способ разобраться во всех деталях - изучить исходники майнера. Я взялся изучать Verilog исходники FPGA майнера - нашел несколько примеров на github, все они, хоть и разных авторов, похоже работают приблизительно по одной схеме. Вполне возможно, что автор то у них всех изначально был один, просто разные разработчики адаптируют один и тот же майнер под разные чипы и разные платы.. По крайней мере мне так показалось..

Вот и я, поизучав исходники Verilog, адаптировал проект с github к плате Марсоход3 на основе ПЛИС Altera MAX10, 50 тыс. логических элементов. Я смог запустить свой майнер и даже смог запустить процесс вычисления биткоинов, но бросил это дело через пол часа из-за бесперспективности. Слишком медленно по нынешним временам работает мой FPGA майнер. Ну и пусть.

Честно говоря, меня во всем этом проекте заинтересовали не сами биткоины (ну их, эти денежные суррогаты ))), но скорее математическая сторона алгоритма SHA256. Вот об этом я и хотел бы рассказать. Я провел несколько экспериментов с алгоритмом SHA256, может быть результаты этих экспериментов покажутся вам интересными. Дальше будет немного языка C и немного Verilog.

Первое, что мне нужно было сделать для моих экспериментов - это написать "чистую" реализацию SHA256 на Verilog.

На самом деле реализаций алгоритма SHA256 в Verilog много, хоть на том же opencores.org, хоть на github.com. Однако, мне такие реализации не подходят для экспериментов. Имеющиеся модули всегда имеют конвейерную структуру, pipeline. Казалось бы - это правильно. Только при наличии pipeline можно получить высокую скорость работы алгоритма. Алгоритм SHA256 состоит из 64 этапов обработки, так называемых "раундов". Если объем ПЛИС позволяет, то можно развернуть все 64 раунда в единую цепочку операций: вре этапы вычислений производятся параллельно за один такт рабочей частоты. Пока в регистры первого раунда загружаются новые данные, второй раунд продолжает считать данные загруженные на предыдущем такте, третий раунд продолжает считать, то, что было загружено на пред-предыдущем такте и так далее. Итоговая латенси, то есть задержка результата вычислений как раз и будет 64 такта, но в целом конвейер/pipeline как бы позволяет считать весь алгоритм за 1 такт. Если объем ПЛИС не позволяет развернуть всю цепочку раундов, то ее укорачивают вдвое. Так получается уместить проект в имеющеюся ПЛИС, но и скорость вычислений естественно падает вдвое. Можно взять еще менее емкую ПЛИС и вместить туда, но придется еще вдвое укоротить pipeline. Как я понял на весь Bitcoin майнер, в котором два подряд SHA256-transform нужно около 80-ти тысяч логических элементов. Но это я отвлекся..

Итак, я хочу сделать совершенно абсурдную вещь - написать на Verilog "чистую" функцию алгоритма SHA256 без промежуточных регистров, оставить ее без конвейера. Цель у этого странного действия простая - определить реальное количество логики, необходимое для вычисления алгоритма SHA256. Мне нужна простая комбинацинная схема, которой подаешь на вход 512 бит данных и она выдает 256 бит результата.

Я написал этот Verilog модуль, где-то что-то сам писал, что-то позаимствовал из других открытых проектов. Вот он:

Естественно, нужно убедиться, что модуль работает. Для этого нужен простой тестбенч, чтоб подать на вход какой-то блок данных и посмотреть результат. Сравнивать буду с ответом, который мне выдает функция sha256_transform, написанная на языке C:

Убедился, что ответы совпадают, значит можно двигаться дальше.

Теперь можно вставить модуль в ПЛИС и посмотреть сколько же логических элементов может занимать такая функция.
Делаем такой проект.

Первое, что мне пришло в голову: зачем при поиске биткоинов вычисляется весь хэш? 



